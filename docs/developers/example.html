<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Tutorial · Scalafix</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="In this document, we are going to implement a rewrite rule called"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Tutorial · Scalafix"/><meta property="og:type" content="website"/><meta property="og:url" content="https://olafurpg.github.io//scalafix/index.html"/><meta property="og:description" content="In this document, we are going to implement a rewrite rule called"/><meta property="og:image" content="https://olafurpg.github.io//scalafix/img/scalacenter2x.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://olafurpg.github.io//scalafix/img/scalacenter2x.png"/><link rel="shortcut icon" href="/scalafix/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><link rel="stylesheet" href="/scalafix/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/scalafix/"><img class="logo" src="/scalafix/img/scalacenter2x.png" alt="Scalafix"/><h2 class="headerTitleWithLogo">Scalafix</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/scalafix/docs/users/installation.html" target="_self">User guide</a></li><li class=""><a href="/scalafix/docs/developers/setup.html" target="_self">Developer guide</a></li><li class=""><a href="https://github.com/calacenter/scalafix" target="_blank">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/calacenter/scalafix/edit/master/docs/developers/example.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 class="postHeaderTitle">Tutorial</h1></header><article><div><span><p>In this document, we are going to implement a rewrite rule called
<code>NamedLiteralArguments</code>. The rule produces the following diff</p>
<pre><code class="hljs css language-diff">  def complete(isSuccess: Boolean): Unit = ???
<span class="hljs-deletion">- complete(true)</span>
<span class="hljs-addition">+ complete(isSuccess = true)</span>
</code></pre>
<p>The final product can be cloned from the repository
<a href="https://github.com/olafurpg/named-literal-arguments">olafurpg/named-literal-arguments</a>.
Feel free to play around with that codebase while reading this tutorial.</p>
<p>By implementing <code>NamedLiteralArguments</code>, you will learn how to</p>
<ul>
<li>write unit tests for rewrite rules</li>
<li>use pattern matching to find interesting tree nodes</li>
<li>use <code>SymbolInfo</code> to look up method signatures</li>
<li>publishing our custom rule so that users can run it on their codebase</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="write-unit-tests"></a><a href="#write-unit-tests" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Write unit tests</h2>
<p>Branch:
<a href="https://github.com/olafurpg/named-literal-arguments/tree/step-1">step-1</a></p>
<p>We start by creating a small sbt build with a failing unit test. The build is
composed of four projects</p>
<ul>
<li><code>rules</code>: where the <code>NamedLiteralArguments</code> rewrite rule is implemented</li>
<li><code>input</code>: where the code before the rewrite gets applied is written</li>
<li><code>output</code>: where the expected code after the rewrite has applied is written</li>
<li><code>tests</code>: where we run the unit tests</li>
</ul>
<p>Start by running <code>sbt tests/test</code> and see the tests fail</p>
<pre><code class="hljs css language-diff"> &gt; ~tests/test
<span class="hljs-comment">--- obtained</span>
<span class="hljs-comment">+++ expected</span>
<span class="hljs-meta">@@ -4,3 +4,3 @@</span>
   def complete(isSuccess: Boolean): Unit = ()
<span class="hljs-deletion">-  complete(true)</span>
<span class="hljs-addition">+  complete(isSuccess = true)</span>
 }
</code></pre>
<p>Observe that we expected the output to be <code>complete(isSuccess = true)</code> but the
obtained output was <code>complete(true)</code>. This makes sense since our
<code>NamedLiteralArguments</code> rule currently returns <code>Patch.empty</code>, which produces an
empty diff.</p>
<h2><a class="anchor" aria-hidden="true" id="use-pattern-matching-to-find-interesting-tree-nodes"></a><a href="#use-pattern-matching-to-find-interesting-tree-nodes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Use pattern matching to find interesting tree nodes</h2>
<p>Branch:
<a href="https://github.com/olafurpg/named-literal-arguments/commit/e393c4a8575870a385cd1763f6a499db090847d9">step-2</a></p>
<p>We update the rule implementation to traverse the syntax tree and find
occurrences of the literal <code>true</code>.</p>
<pre><code class="hljs css language-scala">doc.tree.collect {
  <span class="hljs-keyword">case</span> t @ <span class="hljs-string">q"true"</span> =&gt; <span class="hljs-type">Patch</span>.addLeft(t, <span class="hljs-string">"isSuccess = "</span>)
}.asPatch
</code></pre>
<p>Let's break this down one part at a time:</p>
<ul>
<li><code>doc.tree.collect { case .. =&gt; ...}</code>: this performs a top-to-bottom traversal
of the syntax tree visiting every tree node.</li>
<li>we construct a pattern <code>q&quot;true&quot;</code> which is a
<a href="https://github.com/scalameta/scalameta/blob/master/notes/quasiquotes.md">Scalameta &quot;quasi-quotes&quot;</a>.
Quasiquotes are great for writing simple hard-coded patterns like in this
case.</li>
<li><code>Patch.addLeft(t, &quot;isSuccess = &quot;)</code>: describes a refactoring on the source code
that adds the string <code>isSuccess =</code> to the left side of the <code>true</code> literal.</li>
<li><code>List[Patch].asPatch</code>: helper method to convert a list of patches into a
single patch.</li>
</ul>
<p>Branch:
<a href="https://github.com/olafurpg/named-literal-arguments/commit/fa3780228a1811d6551339c5df05ff49df6ba552"><code>step-3</code></a></p>
<p>In <code>step-3</code> we add more complicated test cases and update the rule to handle
make those test cases pass.</p>
<p>The first improvement is that we handle any boolean literal, regardless if it's
<code>true</code> or <code>false</code>.</p>
<pre><code class="hljs css language-diff"><span class="hljs-deletion">-  case t @ q"true" =&gt;</span>
<span class="hljs-addition">+  case t @ Lit.Boolean(_) =&gt;</span>
</code></pre>
<p>We replace the <code>q&quot;true&quot;</code> quasi-quote with <code>Lit.Boolean(_)</code>. In my experience,
quasi-quotes are great for large static tree nodes but &quot;normal&quot; pattern matching
such as <code>Lit.Boolean(_)</code> can be more flexible.</p>
<p><strong>Pro tip.</strong> If you don't know the name of the tree node you want to match, use
<code>tree.structure</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scalafix.v1._

<span class="hljs-keyword">import</span> scala.meta._

<span class="hljs-keyword">val</span> x = <span class="hljs-string">q"complete(true)"</span>
<span class="hljs-comment">// x: Term.Apply = Term.Apply(Term.Name("complete"), List(Lit.Boolean(true)))</span>

println(x.structure)
<span class="hljs-comment">// Term.Apply(Term.Name("complete"), List(Lit.Boolean(true)))</span>
</code></pre>
<p>The next improvement was to ensure that we only rewrite <code>true</code> literals that
appear in function argument position. Previously, the rewrite would replace all
appearances of <code>true</code>, producing problematic diffs like this</p>
<pre><code class="hljs css language-diff"><span class="hljs-deletion">- val isComplete = true</span>
<span class="hljs-addition">+ val isComplete = isSuccess = true</span>
</code></pre>
<p>To fix this bug, we first match function call nodes <code>Term.Apply</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-type">Term</span>.<span class="hljs-type">Apply</span>(_, args) =&gt;
  args.collect {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Lit</span>.<span class="hljs-type">Boolean</span>(_) =&gt; <span class="hljs-comment">// ...</span>
  }
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="use-symbolinfo-to-lookup-method-signatures"></a><a href="#use-symbolinfo-to-lookup-method-signatures" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Use <code>SymbolInfo</code> to lookup method signatures</h2>
<p>Branch:
<a href="https://github.com/olafurpg/named-literal-arguments/commit/da9324258f223463e46e4fbc22b14c2d2801ee0a"><code>step-4</code></a></p>
<p>Our rule is still buggy because we have hard-coded <code>isSuccess</code>. Let's add a case
where we need to insert a different name <code>isError</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">complete</span></span>(isSuccess: <span class="hljs-type">Boolean</span>): <span class="hljs-type">Unit</span> = ()
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">finish</span></span>(isError: <span class="hljs-type">Boolean</span>): <span class="hljs-type">Unit</span> = ()
complete(<span class="hljs-literal">true</span>)
finish(<span class="hljs-literal">true</span>)
</code></pre>
<p>Branch:
<a href="https://github.com/olafurpg/named-literal-arguments/commit/4e0127d501cf652b5d4ce6a24fba8afc1a9c54ea"><code>step-5</code></a></p>
<p>To fix this bug, we start by binding the tree of the function call into a
variable <code>fun</code></p>
<pre><code class="hljs css language-diff"><span class="hljs-deletion">- case Term.Apply(_, args) =&gt;</span>
<span class="hljs-addition">+ case Term.Apply(fun, args) =&gt;</span>
</code></pre>
<p>Next, we use the method <code>Tree.symbol.info</code> to query information about the method
we are calling</p>
<pre><code class="hljs css language-diff">  case Lit.Boolean(_) =&gt;
<span class="hljs-addition">+   fun.symbol.info match {</span>
<span class="hljs-addition">+     case Some(info) =&gt;</span>
        // ...
<span class="hljs-addition">+     case None =&gt; Patch.empty</span>
<span class="hljs-addition">+   }</span>
</code></pre>
<ul>
<li>A <code>Symbol</code> is a unique identifier for a single definition such as a <code>val</code> or a
<code>class</code></li>
<li>A <code>SymbolInfo</code> contains metadata about a symbol.</li>
</ul>
<p>Next, we use <code>SymbolInfo.signature</code> to see if the symbol is a method with a
non-empty parameter list.</p>
<pre><code class="hljs css language-diff"><span class="hljs-addition">+ info.signature match {</span>
<span class="hljs-addition">+   case method: MethodSignature if method.parameterLists.nonEmpty =&gt;</span>
      // ...
<span class="hljs-addition">+   case _ =&gt; Patch.empty</span>
<span class="hljs-addition">+ }</span>
</code></pre>
<p>The final step is to extract the parameter at the index of the argument</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> parameter = method.parameterLists.head(i)
<span class="hljs-keyword">val</span> parameterName = parameter.displayName
<span class="hljs-type">Patch</span>.addLeft(t, <span class="hljs-string">s"<span class="hljs-subst">$parameterName</span> = "</span>)
</code></pre>
<p>That completes out rule! The final result will look something like this</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// NamedLiteralArguments.scala</span>
<span class="hljs-keyword">package</span> fix

<span class="hljs-keyword">import</span> scalafix.v1._
<span class="hljs-keyword">import</span> scala.meta._

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NamedLiteralArguments</span></span>
    <span class="hljs-keyword">extends</span> <span class="hljs-type">SemanticRule</span>(<span class="hljs-string">"NamedLiteralArguments"</span>) {
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fix</span></span>(<span class="hljs-keyword">implicit</span> doc: <span class="hljs-type">SemanticDocument</span>): <span class="hljs-type">Patch</span> = {
    doc.tree
      .collect {
        <span class="hljs-keyword">case</span> <span class="hljs-type">Term</span>.<span class="hljs-type">Apply</span>(fun, args) =&gt;
          args.zipWithIndex.collect {
            <span class="hljs-keyword">case</span> (t @ <span class="hljs-type">Lit</span>.<span class="hljs-type">Boolean</span>(_), i) =&gt;
              fun.symbol.info <span class="hljs-keyword">match</span> {
                <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(info) =&gt;
                  info.signature <span class="hljs-keyword">match</span> {
                    <span class="hljs-keyword">case</span> method: <span class="hljs-type">MethodSignature</span>
                        <span class="hljs-keyword">if</span> method.parameterLists.nonEmpty =&gt;
                      <span class="hljs-keyword">val</span> parameter = method.parameterLists.head(i)
                      <span class="hljs-keyword">val</span> parameterName = parameter.displayName
                      <span class="hljs-type">Patch</span>.addLeft(t, <span class="hljs-string">s"<span class="hljs-subst">$parameterName</span> = "</span>)
                    <span class="hljs-keyword">case</span> _ =&gt;
                      <span class="hljs-comment">// Do nothing, the symbol is not a method.</span>
                      <span class="hljs-type">Patch</span>.empty
                  }
                <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt;
                  <span class="hljs-comment">// Do nothing, no information about this symbol.</span>
                  <span class="hljs-type">Patch</span>.empty
              }
          }
      }
      .flatten
      .asPatch
  }
}
</code></pre>
<p>Let's try to run the rule on different codebases.</p>
<h2><a class="anchor" aria-hidden="true" id="publish-your-rule-as-source-code"></a><a href="#publish-your-rule-as-source-code" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Publish your rule as source code</h2>
<p>Fork the olafurpg/named-argument-literals repository, open</p>
<h2><a class="anchor" aria-hidden="true" id="publish-your-rule-to-maven-central"></a><a href="#publish-your-rule-to-maven-central" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Publish your rule to Maven Central</h2>
<p>Branch:
<a href="https://github.com/olafurpg/named-literal-arguments/commit/88f18b16c9dd939a3f1c08672b121ac2bc1c590d"><code>step-6</code></a></p>
<p>The final step is to share our rule so that other people can run it on their
codebase. This involves updating build.sbt to publish the rule to Sonatype.</p>
<p>Once you</p>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#write-unit-tests">Write unit tests</a></li><li><a href="#use-pattern-matching-to-find-interesting-tree-nodes">Use pattern matching to find interesting tree nodes</a></li><li><a href="#use-symbolinfo-to-lookup-method-signatures">Use <code>SymbolInfo</code> to lookup method signatures</a></li><li><a href="#publish-your-rule-as-source-code">Publish your rule as source code</a></li><li><a href="#publish-your-rule-to-maven-central">Publish your rule to Maven Central</a></li></ul></nav></div><footer class="nav-footer" id="footer" style="background-color:#15242B"><section class="sitemap"><a href="/scalafix/" class="nav-home"><img src="/scalafix/img/scalacenter2x.png" alt="Scalafix" width="66" height="58"/></a><div><h5>Docs</h5><a href="
                /scalafix/docs/users/installation.html">Get started</a><a href="
                /scalafix/docs/rules/overview.html">Rules</a><a href="
                /scalafix/docs/developers/setup.html">Extend Scalafix</a></div><div><h5>Community</h5><a href="https://gitter.im/scalacenter/scalafix" target="_blank">Chat on Gitter</a><a href="https://users.scala-lang.org/" target="_blank">Discuss on Scala Users</a></div><div><h5>More</h5><a href="https://github.com/calacenter/scalafix" target="_blank">GitHub</a></div></section><section class="copyright">Copyright © 2018 Scala Center</section></footer></div></body></html>